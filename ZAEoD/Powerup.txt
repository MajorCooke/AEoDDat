//--------------------------------------------------------------------

Class ForceCube : CustomInventory
{
	Default
	{
		+FLOATBOB
		+COUNTITEM
		+INVENTORY.FANCYPICKUPSOUND
		+INVENTORY.INVBAR
		+DONTGIB
		Inventory.MaxAmount 10;
		Inventory.Icon "HFCB1Z";
		Inventory.PickupSound "reilsss/powerup/ForceCube";
		Inventory.PickupMessage "You found a force cube!";
		Inventory.UseSound "ForceCube/Use";
		Scale 0.4;
		Tag "Attack foes (timed)";
	}
	States
	{
	Spawn:
		FCB1 ABCDEFGHIJKLMNOP 4 Bright;
		Loop;
	Use:
		TNT1 A 0
		{
			if (!CountInv("PowerDemonMorph"))
			{		
				if (!CountInv("LeftCubeToken"))
				{
					A_SpawnItemEx("LeftCube",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_SETTARGET|SXF_TRANSFERPITCH);
					A_GiveInventory("LeftCubeToken",1);
					return true;
				}
				if (!CountInv("RightCubeToken"))
				{
					A_SpawnItemEx("RightCube",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_SETTARGET|SXF_TRANSFERPITCH);
					A_GiveInventory("RightCubeToken",1);
					return true;
				}
			}
			return false;
		}
		Stop;
	}
}

Class RealForceCube : Actor
{
	double YPos;
	Class<Inventory> CubeToken;
	
	Property YPos: YPos;
	Property CubeToken: CubeToken;
}

Class RightCube : RealForceCube
{
	const Lifetime = 1575;
	int countdown;
	int uang;
	
	Default
	{
		RealForceCube.YPos 12;
		RealForceCube.CubeToken "RightCubeToken";
		Projectile;
		+NOINTERACTION
		+SEEKERMISSILE
		Radius 1;
		Height 1;
		Speed 0;
		Scale 0.1;
		MinMissileChance 0;
	}
	
	override void PostBeginPlay()
	{
		countdown = Lifetime;
		Super.PostBeginPlay();
	}
	
	override void OnDestroy()
	{
		if (target && CubeToken)	target.A_SetInventory(CubeToken,0);
		Super.OnDestroy();
	}
	
	States
	{
	Spawn:
		FCB2 A 1 NoDelay
		{
			if (!target || countdown < 1)	{ Destroy(); return; }
			
			A_SeekerMissile(0,0,SMF_LOOK,256);
			if (tracer && tracer.health > 0)
			{
				A_FaceTracer(0,0,0,0,FAF_MIDDLE);
				//A_CustomRailgun(4,0,"","",RGF_SILENT,0,0,"CubePuff",0,0,0,0,5.0,0,"ForceCubeTrail");
				Actor puff = LineAttack(angle, 32767, pitch, 0, "Normal", "BeamSpawnerPuff", LAF_NOINTERACT, null, height * 0.5);
				if (puff)
				{
					let arc = ForceCubeBeamSpawner(Spawn("ForceCubeBeamSpawner",pos + (0, 0, 7.5)));
					if (arc)
					{
						arc.master = self;
						arc.angle = angle;
						arc.pitch = pitch;
						arc.Puff[2] = puff;
					}
				}
				A_CustomRailgun(4,0,"","",RGF_SILENT,0,0,"CubePuff",0,0,0,0,5.0,0);
				
				A_PlaySound("ForceCube/Fire",5,1,true);
				tracer = null;
			}
			else
			{
				A_StopSound(5);
			}
			Warp(target, 20, YPos, 36 * target.GetCrouchFactor(),0,WARPF_INTERPOLATE|WARPF_NOCHECKPOSITION);
			A_Weave(0,1,0,3);
			countdown--;
		}
		Wait;
	}
}

Class LeftCube : RightCube
{
	Default
	{
		RealForceCube.CubeToken "LeftCubeToken";
		RealForceCube.YPos -12;
	}
}

Class ForceCubeTrail : Actor
{
	Default
	{
		+NOINTERACTION
		Scale 0.25;
		Alpha 0.2;
		RenderStyle "Add";
		Translation "0:255=%[0,0,0]:[1,0.85,0]";
	}
	
	override void PostBeginPlay()
	{
		A_SetScale(frandom(0.25,0.65));
		Super.PostBeginPlay();
	}
	
	States
	{
	Spawn:
		TNT1 A 0 
		{
			
		}
		LPUF A 1 Bright;
		LPUF A 1 Bright
		{
			if (Scale.X <= 0.0)
			{	Destroy(); return;	}
			
			A_SetScale(Scale.X - 0.05);
		}
		Wait;
	}
}

Class CubePuff : Actor
{
	Default
	{
		Projectile;
		+PUFFGETSOWNER
		+BLOODLESSIMPACT
		DamageType "TempestLightning";
	}
	States
	{
	Spawn:
		TNT1 A 0;
		Stop;
	}
}
Class RightCubeToken : Inventory
{
	Default
	{
		Inventory.MaxAmount 1;
		Inventory.InterHubAmount 0;
	}
}
 
Class LeftCubeToken : Inventory
{
	Default
	{
		Inventory.MaxAmount 1;
		Inventory.InterHubAmount 0;
	}
}

/*==============================================================================
================================================================================
								The Deadlights
				Graphics from Happy Time Circus 2 by Shtbag555
							 Coded by Major Cooke
							 
	What spawned IT? Where does he come from? A side question the rejects
	often asked themselves, but whatever answer lie out of reach, it's
	well beyond their understanding. That goddamn clown will never let 
	go of his hate.
	
	Injured by battery acid, he found this to be a serious flaw in his
	defensive abilities. This would not suffice. He needed to perfect his
	mortal form and prevent such things from being a weakness ever again.
	The idea came to him one night when he was about to devour two children
	resting on a hillside, staring up at the clear night sky, silently
	sneaking upon them. Preparing for a test, they were quizzing one another
	over the capabilities of stars, and several questions caught his
	attention. Brilliant questions and answers. Retreating to his lair under
	the sewers, he forged them with several traits of the stars in mind,
	forming eight deadly orbiting projectiles that damage and slice through
	anything they touch.
	
	The deadlights are made from an unknown material that has different
	reactions based on whom the owner is. For Pennywise, they render him
	completely invulnerable to any and all attacks from outsiders as he
	he uses very little energy when moving. Humans on the other hand do
	use up a bunch of energy, and thus the deadlights can only afford to
	render them temporarily invulnerable upon being stricken, and reflecting
	the attack back at the offender. This invulnerability is so strong, it
	can even deflect the particle phase-injections of the teleporters, which
	makes enemies explode from the inside out when something is teleporting
	onto the spot that happens to be in the way.
	
================================================================================
==============================================================================*/

Class DeadLightPowerup : CustomInventory
{
	Default
	{
		Inventory.MaxAmount 3;
		Inventory.Amount 1;
		Inventory.InterHubAmount 3;
		Inventory.PickupSound "HTC2/Deadlight/Pickup";
		Inventory.UseSound "HTC2/Deadlight/Activate";
		Inventory.PickupMessage "You won the Dead Lights! Drive your enemies through multi-colored madness!";
		+INVENTORY.INVBAR
		+VISIBILITYPULSE
		+DONTGIB
		Inventory.Icon "X091A0";
		Species "Permanent";
		//+FLOATBOB
		Tag "Invulnerable when hit, floating deadlights hurt nearby enemies, reflecting projectiles";
	}
	States
	{
	Spawn:
		X091 A 2 Light("DeadWhite");
        X091 B 2 Light("DeadRed");
        X091 C 2 Light("DeadGreen");
        X091 D 2 Light("DeadBlue");
		Loop;
	Use:
		TNT1 A 0 
		{
			if (CountInv("PowerDemonMorph") || CountInv("PowerDLProtector"))
			{	return false;	}
			A_GiveInventory("DLPowerEffect",1);
			A_SetReflective();
			//A_SpawnItemEx("DLController",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_SETMASTER);
			//A_SpawnItemEx("DLMonitor",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_SETMASTER);
			A_PlaySound("powerups/pentagramuse",5,1,0,ATTN_NONE);
			A_PlaySound("powerups/pentagramuse",6,1,0,ATTN_NONE);
			A_SpawnItemEx("PlayerDeadLightWarp",0,0,30,12,0,0,0,SXF_NOCHECKPOSITION|SXF_SETMASTER);
			A_SpawnItemEx("PlayerDeadLightWarp",0,0,30,12,0,0,90,SXF_NOCHECKPOSITION|SXF_SETMASTER);
			A_SpawnItemEx("PlayerDeadLightWarp",0,0,30,12,0,0,180,SXF_NOCHECKPOSITION|SXF_SETMASTER);
			A_SpawnItemEx("PlayerDeadLightWarp",0,0,30,12,0,0,270,SXF_NOCHECKPOSITION|SXF_SETMASTER);
			A_SpawnItemEx("PlayerDeadLightWarp2",0,0,30,12,0,0,0,SXF_NOCHECKPOSITION|SXF_SETMASTER);
			A_SpawnItemEx("PlayerDeadLightWarp2",0,0,30,12,0,0,90,SXF_NOCHECKPOSITION|SXF_SETMASTER);
			A_SpawnItemEx("PlayerDeadLightWarp2",0,0,30,12,0,0,180,SXF_NOCHECKPOSITION|SXF_SETMASTER);
			A_SpawnItemEx("PlayerDeadLightWarp2",0,0,30,12,0,0,270,SXF_NOCHECKPOSITION|SXF_SETMASTER);
			return true;
		}
		Stop;
	}
}

Class PowerDLProtector : PowerProtection
{
	bool modded;
	Default
	{
		DamageFactor "Normal", 0.6;
		Inventory.Icon "X091A0";
	}
	
	override void InitEffect()
	{
		if (owner)
		{
			owner.bJUSTHIT = true;
		}
		Super.InitEffect();
	}
	/*
	override void ModifyDamage(int damage, Name damageType, out int newdamage, bool passive) 
	{
		if (passive && Owner && (Owner.ApplyDamageFactor(damageType, damage) > 0) && !Owner.CountInv("PowerFake"))
		{
			modded = true;
			Owner.bJUSTHIT = true;
			//owner.A_GiveInventory("DLFlasher",1);
		}
		newdamage = damage;
	}
	
	override void AbsorbDamage (int damage, Name damageType, out int newdamage) 
	{
		if (!modded && Owner && (Owner.ApplyDamageFactor(damageType, damage) > 0) && !owner.CountInv("PowerFake"))
		{
			Owner.bJUSTHIT = true;
			//owner.A_GiveInventory("DLFlasher",1);
		}
		newdamage = damage;
	}
	*/
	override void DoEffect()
	{
		if (owner)
		{
			owner.bREFLECTIVE = true;
			if (owner.bJUSTHIT && !owner.CountInv("PowerFake") && !owner.bINVULNERABLE && !owner.bNODAMAGE)
			{
				owner.A_GiveInventory("DLFlasher",1);
			}
			owner.bJUSTHIT = false;
		}
		Super.DoEffect();
	}
	
	override void EndEffect()
	{
		if (owner)
		{
			if (EffectTics > 0)	return;
			if (!owner.CountInv("PowerPlayerGrounder"))
				owner.bREFLECTIVE = false;
			owner.A_KillChildren("Normal",KILS_KILLMISSILES,null,'PlayerDeadLight');
		}
		Super.EndEffect();
	}
	
	override void OwnerDied()
	{
		EndEffect();
		Super.OwnerDied();
	}
}

Class PowerFake : PowerProtection
{
	Default
	{
		+INVENTORY.NOSCREENBLINK;
		DamageFactor "Normal", 1.0;
		Powerup.Duration 45;
	}
	
	override void InitEffect()
	{
		if (owner)
		{			
			owner.bINVULNERABLE = owner.bNODAMAGE = owner.bNOPAIN = true;
		}
		Super.InitEffect();
	}
	
	override void EndEffect()
	{
		if (owner)
		{
			let inv = PowerInvulnerable(owner.FindInventory("PowerInvulnerable",true));
			owner.bINVULNERABLE = (inv != null);
			owner.bNODAMAGE = (Owner.CountInv("PowerPlayerGrounder") != 0);
			Owner.bNOPAIN = (inv || Owner.CountInv("PowerPlayerGrounder") != 0);
		}
		Super.EndEffect();
	}
	
}

Class DLPowerEffect : PowerupGiver
{
	Default
	{
		Powerup.Type "PowerDLProtector";
		Powerup.Duration -666;
		Inventory.MaxAmount 0;
		Inventory.InterHubAmount 0;
		+INVENTORY.ALWAYSPICKUP
		+INVENTORY.AUTOACTIVATE
	}
}

Class DLFlasher : PowerupGiver
{
	Default
	{
		Powerup.Type "PowerFake"; //Doesn't matter, invulnerable when this happens.
		Inventory.MaxAmount 0;
		Powerup.Duration 45;
		Powerup.Colormap 0.0, 0.0, 0.0, 1.0, 1.0, 1.0;
		+INVENTORY.NOSCREENBLINK
		+INVENTORY.ALWAYSPICKUP
		+INVENTORY.AUTOACTIVATE
	}
}

Class DeadlightToken : Inventory
{
	Default
	{
		Inventory.MaxAmount 1;
		Inventory.InterHubAmount 0;
	}
}

Class PlayerDeadLightWarp : Actor
{
	int dirMove;
	Property AngleMove: dirMove;
	Default
	{
		PlayerDeadLightWarp.AngleMove 3;
		BounceFactor 1;
		WallBounceFactor 1;
		Height 16;
		Projectile;
		+SEEKERMISSILE
		+FORCERADIUSDMG
		+STRIFEDAMAGE
		+NOINTERACTION
		+EXTREMEDEATH
		+FOILINVUL
		+NODAMAGETHRUST
		+DONTSPLASH
		Alpha 0.3;
		Scale 0.5;
		Speed 12;
		Damage 1;
		Species "PlayerDeadLight";
		RenderStyle "Translucent";
	}
	
	States
	{
	Spawn:
		X091 A 0;
	PreMove:
		X091 A 1 Light("DeadWhite") A_Explode(random(6,12),32,0,0,32);
        X091 B 1 Light("DeadRed") A_Explode(random(6,12),32,0,0,32);
        X091 C 1 Light("DeadGreen") A_Explode(random(6,12),32,0,0,32);
        X091 D 1 Light("DeadBlue") A_Explode(random(6,12),32,0,0,32);
		X091 A 1 Light("DeadWhite") A_Explode(random(6,12),32,0,0,32);
        X091 B 1 Light("DeadRed") A_Explode(random(6,12),32,0,0,32);
        X091 C 1 Light("DeadGreen") A_Explode(random(6,12),32,0,0,32);
        X091 D 1 Light("DeadBlue") A_Explode(random(6,12),32,0,0,32);
	Warping:
		X091 A 1 Light("DeadWhite") 
		{
			A_Weave(0,1,0,10);
			A_Warp(AAPTR_MASTER,92,0,32,dirMove,WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE|WARPF_USECALLERANGLE);
			A_Explode(random(6,12),32,0,0,32);
		}
		X091 B 1 Light("DeadRed") 
		{
			A_Weave(0,1,0,10);
			A_Warp(AAPTR_MASTER,92,0,32,dirMove,WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE|WARPF_USECALLERANGLE);
			A_Explode(random(6,12),32,0,0,32);
		}
		X091 C 1 Light("DeadGreen") 
		{
			A_Weave(0,1,0,10);
			A_Warp(AAPTR_MASTER,92,0,32,dirMove,WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE|WARPF_USECALLERANGLE);
			A_Explode(random(6,12),32,0,0,32);
		}
		X091 D 1 Light("DeadBlue") 
		{
			A_Weave(0,1,0,10);
			A_Warp(AAPTR_MASTER,92,0,32,dirMove,WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE|WARPF_USECALLERANGLE);
			A_Explode(random(6,12),32,0,0,32);
		}
		Loop;
	Death:
		X091 E 4 
		{
			A_Stop();
			bNOINTERACTION = true;
		}
		X091 F 4 Bright 
		{
			A_Explode(96,128,0);
			
			for (int i = 0; i < 41; i++)
				A_SpawnProjectile("Sparkles", 8, 0, random(-180, 180), 2, random(-180, 180));
		}
		X091 G 4 Bright 
		{
			for (int i = 0; i < 82; i++)
				A_SpawnProjectile("Sparkles", 8, 0, random(-180, 180), 2, random(-180, 180));
		}
        X091 HI 4 Bright;
		X087 JKL 4 Bright;
        Stop;
	Ender:
		TNT1 A 0;
		Stop;
	}
}

Class PlayerDeadLightWarp2 : PlayerDeadLightWarp
{
	Default
	{
		PlayerDeadLightWarp.AngleMove -3;
	}
}



//==============================================================================
//==============================================================================
// Pentagram Of Protection
//==============================================================================
//==============================================================================

Class PentagramOfProtection : CustomInventory 
{
	Default
	{
		Inventory.PickupMessage "Pentagram Of Protection";
		Inventory.PickupSound "powerups/pentagrampickup";
		Inventory.Amount 1;
		Inventory.MaxAmount 10;
		Inventory.InterHubAmount 10;
		Inventory.UseSound "";
		Scale 0.25;
		Species "Permanent";
		Inventory.Icon "HARTPENT";
		Tag "Invulnerable (timed)";
		+COUNTITEM
		+FLOATBOB
		+DONTGIB
		+INVENTORY.INVBAR
		+INVENTORY.FANCYPICKUPSOUND
	}
	
    States
    {
    Spawn:
		QPEI A 0 NoDelay
		{
			if (random(1,256) < 256 - 224)
			{
				A_SpawnItemEx("DemonMorphPowerup",0,0,0,vel.x,vel.y,vel.z,0,SXF_NOCHECKPOSITION|SXF_ABSOLUTEMOMENTUM|SXF_TRANSFERSPECIAL,0,tid);
				Destroy(); return;
			}
		}
	Form:
		QPEI ABCDEFGHIJKLMNOP 3 Bright;
		Loop;
    Use:
		TNT1 A 0 
		{
			if (CountInv("PowerDemonMorph") || CountInv("PowerInvulBase"))
				return false;
			bNOPAIN = true;
			A_GiveInventory("UnMorpher",1);
			A_GiveInventory("Invulnerability",1);
			A_PlaySound("powerups/pentagramuse",CHAN_BODY,1,0,ATTN_NONE);
			A_SpawnItemEx("PentagramChecker",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_SETTARGET|SXF_SETMASTER);
			return true;
		}
		Stop;
    }
}

Class Invulnerability : PowerupGiver
{
	Default
	{
		+INVENTORY.AUTOACTIVATE
		+INVENTORY.QUIET
		+INVENTORY.NOSCREENBLINK
		Powerup.Color "Gold", 0.10;
		Powerup.Type "PowerInvulBase";
		Powerup.Duration 700;
	}
}

Class PowerInvulBase : PowerInvulnerable
{
	const MaxTics = 35;
	const PentaDelay = 70;
	int delay;
	int ticks;
	double alfa;
	bool silent; bool modded;
	Property Silent: silent;
	Default
	{
		PowerInvulBase.Silent false;
		+INVENTORY.NOSCREENBLINK
		Inventory.icon "ARTPENTB";
	}
	
	override void InitEffect()
	{
		if (owner)
		{
			if (!silent && EffectTics >= 699) A_PlaySound("powerups/pentagramuse",6,1,0,ATTN_NONE);
			owner.bNOPAIN = true;
		}
		Super.InitEffect();
	}
	
	override void ModifyDamage(int damage, Name damageType, out int newdamage, bool passive) 
	{
		Super.ModifyDamage(damage, damageType, newdamage, passive);
		if (passive)
		{
			modded = true;
			if (damage > 0 && Owner && (Owner.ApplyDamageFactor(damageType, damage) > 0))
			{
				if (delay < 1)
				{
					A_PlaySound("reilsss/powerup/TimeRune",CHAN_AUTO,1.0,false,ATTN_NONE);
					delay = 70;
				}
				
				ticks = clamp(damage / 20, 1, 35);
				alfa = clamp(damage / 100.0, 0.0, 0.5);
				Owner.A_SetBlend("White",alfa,ticks);
			}
		}
		newdamage = damage;
	}
	
	override void AbsorbDamage (int damage, Name damageType, out int newdamage) 
	{
		Super.AbsorbDamage(damage, damageType, newdamage);
		if (!modded && damage > 0 && Owner && (Owner.ApplyDamageFactor(damageType, damage) > 0))
		{
			if (delay < 1)
			{
				A_PlaySound("reilsss/powerup/TimeRune",CHAN_AUTO,1.0,false,ATTN_NONE);
				delay = 70;
			}
			
			ticks = clamp(damage / 20, 1, 35);
			alfa = clamp(damage / 100.0, 0.0, 0.5);
			A_SetBlend("White",alfa,ticks);
		}
		newdamage = damage;
	}
	
	override void DoEffect()
	{
		if (Owner)
		{
			modded = false;
			if (delay > 0)	delay--;
			if (IsFrozen())
			{
				EffectTics++; //'Freeze' the timer.
			}
			else
			{
				Switch (EffectTics)
				{
					Case 105:
						A_PlaySound("powerups/pentagrampickup",5,1,0,ATTN_NONE);
					Case 70:
					Case 35:
						Owner.A_SetBlend("Yellow",0.4,12);
					Default:
						break;
				}
			}
		}
		Super.DoEffect();
	}
	
	override void EndEffect()
	{
		if (owner)
		{
			owner.bNOPAIN = false;
		}
		Super.EndEffect();
	}
}

//No longer used. Kept for compatibility.

Class PentagramChecker : Actor
{
	int user_tick;
	int user_time;
	Default
	{
		+NOINTERACTION
		+NODAMAGE
	}
	States
	{
	Spawn:
		TNT1 A 0;
		Stop;
		/*
		TNT1 A 1 NoDelay
		{
			if (!master)
			{
				Destroy();
				return;
			}
			
			if (CountInv("PentagramCountdown",MasterPtr))
			{
				user_time += CountInv("PentagramCountdown",MasterPtr);
				A_TakeInventory("PentagramCountdown",32767,0,MasterPtr);
				A_StopSound(5);
			}
			else
			{
				user_time--;
			}
			
			if (master)
			{	master.bINVULNERABLE = true;	}
			
			if (user_time == 105 || user_time == 70 || user_time == 35)
			{
				if (user_time == 105)
				{
					A_PlaySound("powerups/pentagrampickup",5,1,0,ATTN_NONE);
				}
				A_GiveInventory("PentagramFade",1,MasterPtr);
			}
			
			if (user_time <= 0 || CountInv("PentagramDispelled",MasterPtr))
			{
				A_SetInventory("PowerInvulBase",0,MasterPtr);
				A_SetInventory("PentagramCountdown",0,MasterPtr);
				A_SetInventory("PentagramDispelled",0,MasterPtr);
				A_SetInventory("PentagramIsOn",0,MasterPtr);
				master.bALLOWPAIN = true;
				master.bNOPAIN = false;
				Destroy();
				return;
			}
			return;
		}
		Wait;
		*/
	}
}

//==============================================================================
//==============================================================================
//								The Demon Morph
//==============================================================================
//==============================================================================

Class DMSoulFragment : CustomInventory
{
	int count;
	int scale1, scale2;
	int gs;
	int t;
	Default
	{
		+INVENTORY.ALWAYSPICKUP
		//+FLOATBOB
		+NOGRAVITY
		+BRIGHT
		+NOTELESTOMP
		-TELESTOMP
		-COUNTITEM
		+DONTGIB
		Species "Permanent";
		Scale 0.0;
		RenderStyle "Add";
		Inventory.PickupSound "reilsss/health/soul";
		Inventory.MaxAmount 0;
	}
	
	States
	{
	Spawn:
		TNT1 A 10 NoDelay 
		{
			A_Stop();
		}
		X099 A 0 
		{
			if (pos.z < floorz + 10.0)
			{	A_Warp(AAPTR_DEFAULT,0,0,10,0,WARPF_NOCHECKPOSITION|WARPF_TOFLOOR);	}
		}
		Goto ScalingUp;
	MoveUp:
		"####" "#" 0 A_Warp(AAPTR_DEFAULT,0,0,10,0,WARPF_NOCHECKPOSITION|WARPF_TOFLOOR);
	ScalingUp:
		"####" "#" 1
		{
			if (invoker.scale1 < 180)
			{
				invoker.scale1 += 5;
				A_SetScale((cos(invoker.scale1 - 90) + 1) * 0.05);
				return ResolveState(null);
			}
			else
			{
				if (invoker.count >= 35 * 15)
				{
					A_SetScale(Scale.X - 0.005);
					if (Scale.X <= 0.0)
					{
						A_RemoveChildren(true,RMVF_EVERYTHING);
						return ResolveState("Null");
					}
					return ResolveState(null);
				}
				else
				{
					invoker.count++;
					invoker.scale2 = (invoker.scale2 + (360 / 35)) % 360;
					A_SetScale(0.05 + (cos(invoker.scale2) * 0.02));
				}
				
			}
			return ResolveState(null);
		}
		Loop;
	Pickup:
		TNT1 A 0 
		{
			A_GiveInventory("DMSoulCount",random(1,6));
			ACS_NamedExecuteAlways("AESoulCount",0,0,0,0);
			if (CountInv("DMSoulCount") >= 666)
			{
				A_TakeInventory("DMSoulCount",666);
				A_GiveInventory("DemonMorphPowerup",1);
			}
			else
			{
				A_GiveInventory("DMSoulHealth",1);
			}
			return true;
		}
		Stop;
	}
}

Class DMSoulFragmentRed : DMSoulFragment
{
	Default
	{
		Translation "0:255=%[0,0,0]:[1,0,0]";
	}
}

Class DemonMorphStartSound : Actor
{
	Default
	{
		+NOINTERACTION
		RenderStyle "None";
	}
	States
	{
	Spawn:
		TNT1 A 0 NoDelay A_PlaySound("DemonMorph/Grow",5|CHAN_NOPAUSE,1,0,ATTN_NONE);
		TNT1 A 10 A_PlaySound("DemonMorph/Start",6|CHAN_NOPAUSE,1,0,ATTN_NONE);
		Stop;
	}
}

Class DMSoulMissile : Actor
{
	Default
	{
		Projectile;
		+SEEKERMISSILE
		+DONTREFLECT
		+THRUACTORS
		+BRIGHT
		RenderStyle "Add";
		Scale 0.05;
		Speed 10;
	}
	States
	{
	Spawn:
	//Unless you know what you're doing...
	//DO NOT FUCK WITH THIS.
	//Sincerely, Management.
		X099 A 0 NoDelay
		{
			if (!tracer || !(tracer is "PlayerPawn"))	
			{	
				Actor temp = tracer;
				tracer = target;
				target = temp;
			}
			A_SeekerMissile(90,90,SMF_PRECISE);
		}
		Goto Looping;
	Looping:
		X099 A 1
		{
			A_FaceTracer(0,0,0,0,FAF_TOP);
			A_ChangeVelocity(cos(pitch)*20,0,-sin(pitch)*20,CVF_RELATIVE|CVF_REPLACE);
			if (!Tracer || 
				Distance3DSquared(Tracer) <= (Tracer.Height ** 2))
			{	return ResolveState("End");	}
			return ResolveState(null);
		}
		Wait;
	Death:
	End:
		// If the player is moving, just spawn the soul fragment at their location to
		// imitate the pickup effect. Otherwise, give it directly.
		X099 A 0 
		{
			if (tracer && tracer is "PlayerPawn")
			{
				SetOrigin(tracer.pos, true);
				Vector3 v = tracer.vel;
				if (v.x || v.y || v.z)
				{
					tracer.A_SpawnItemEx("DMSoulFragment",0,0,8,0,0,1,0,SXF_NOCHECKPOSITION);
				}
				else
				{
					tracer.A_GiveInventory("DMSoulFragment");
				}
			}
		}
		Stop;
	}
}


Class DMSoulCount : Inventory
{
	Default
	{
		+INVENTORY.IGNORESKILL
		-COUNTITEM
		Inventory.Amount 1;
		Inventory.MaxAmount 2000;
		Inventory.InterHubAmount 2000;
	}
}

Class DMSoulHealth : HealthBonus
{
	Default
	{
		+INVENTORY.IGNORESKILL
		-COUNTITEM
		Inventory.MaxAmount 666;
		Inventory.Amount 1;
	}
}

Class DMBlackParticle : Actor
{
	int count;
	Default
	{
		RenderStyle "Translucent";
		+NOINTERACTION
		+NOTIMEFREEZE
		Scale 0.2;
	}
	States
	{
	Spawn:
		X00A A 0 NoDelay A_SetScale(frandom(0.18,0.22));
	Tick:
		X00A A 1 
		{
			A_ChangeVelocity(vel.x*(0.95),vel.y*(0.95),vel.z+(0.005),CVF_REPLACE);
			count++;
			if (count > 4)
			{
				count = 0;
				A_SetScale(Scale.X-0.01);
			}
			return A_JumpIf(Scale.X <= 0.0,"Null");
		}
		Wait;
	}
}

Class DemonMorphPowerup : CustomInventory
{
	int ticking;
	int limit;
	bool picked;
	Default
	{
		+INVENTORY.BIGPOWERUP
		+INVENTORY.QUIET
		+INVENTORY.NOSCREENFLASH
		+INVENTORY.IGNORESKILL
		+FLOATBOB
		+NOTIMEFREEZE
		+DONTGIB
		+NOTELESTOMP
		Species "Permanent";
		RenderStyle "Stencil";
		StencilColor "Black";
		Scale 0.25;
		Inventory.MaxAmount 0;
		Inventory.InterHubAmount 0;
	}
	
	States
	{
	Spawn:
		QPEI A 2
		{
			if (!invoker.limit) {	invoker.limit = random(35 * 5, 35 * 15);	}
			
			invoker.ticking += 2;
			if (invoker.ticking >= invoker.limit)
			{
				A_PlaySound("DemonMorph/Scream",CHAN_AUTO,1,0);
				invoker.ticking = 0;
				invoker.limit = random(35 * 5, 35 * 15);
			}
			
			if (!A_CheckSight("Null"))
			{
				A_SpawnItemEx("DMBlackParticle",0,0,15.5,frandom(2.0,4.0),0,0,random(0,359),SXF_NOCHECKPOSITION);
				for (int i = 0; i < 8; i++)
				{
					A_SpawnItemEx("DMBlackParticle",0,0,15.5,frandom(2.0,4.0),0,0,random(0,359),SXF_NOCHECKPOSITION,192);
				}
			}
		}
		Wait;
	Pickup:
		TNT1 A 0 
		{
			if (GetClass() == "DemonPlayerMorph" || CountInv("AEoDDemonMorphHand") || CountInv("PowerDemonMorph"))
			{
				A_SetBlend("Grey",1,17);
				A_GiveInventory("DemonMorphGiver",1);
				A_GiveInventory("DemonMorphFullBright",1);
				A_SpawnItemEx("DemonMorphStartSound",flags: SXF_NOCHECKPOSITION|SXF_SETMASTER);
				return true;
			}
			if (FindInventory("PowerMorph",true) != null)
			{
				A_LogInt(2);
				ACS_NamedExecuteAlways("ForceUnmorph",0,1,0,0);
				return true;
			}
			
			A_SetInventory("SSRSecondShotToken",0);
			A_SetInventory("SSLSecondShotToken",0);
			A_SetInventory("ElectroDriverToken",0);
			A_SetInventory("SoulReaperAltToken",0);
			A_SpawnItemEx("DemonMorphStartSound",flags: SXF_NOCHECKPOSITION|SXF_SETMASTER);
			
			A_SetInventory("TempHealthToken",0);
			if (health > 200)
			{	A_GiveInventory("TempHealthToken",health + stamina);	}
			
			double np = pitch;
			
			// Silence all sounds.
			for (int i = 1; i < 8; i++)
				A_StopSound(i);
				
			// Keep the previous pitch of the player. That's just fucking annoying.
			if (A_GiveInventory("DemonMorphGiver",1))
			{	
				//A_GiveInventory("DemonMorphFullBright",1);
				if (alternative && alternative.player)
					alternative.pitch = np;
				else
					pitch = np;
				return true;
			}
			else
			{
				return false;
			}
			
		}
		Stop;
		
	}
}
Class DemonMorphFlashed : Inventory { Default { Inventory.InterhubAmount 0; } }

Class DemonMorphGiver : PowerupGiver
{
	Default
	{
		+INVENTORY.AUTOACTIVATE
		+INVENTORY.QUIET
		+INVENTORY.ADDITIVETIME
		+INVENTORY.NOTELEPORTFREEZE
		Powerup.Type "PowerDemonMorph";
		Powerup.Duration 1225;
	}
}

Class PowerDemonMorph : PowerMorph
{
	int waitTics;
	Actor screams;
	Default
	{
		+INVENTORY.NOTELEPORTFREEZE
		PowerMorph.PlayerClass "DemonPlayerMorph";
		//2 | 16 | 32 | 64 | 128 | 256 | 512 | 2048
		PowerMorph.MorphStyle MRF_UNDOALWAYS|MRF_WHENINVULNERABLE|MRF_UNDOBYDEATH|MRF_UNDOBYDEATHFORCED|MRF_UNDOBYDEATHSAVES|MRF_LOSEACTUALWEAPON|MRF_NEWTIDBEHAVIOUR;
		PowerMorph.MorphFlash "OldFog";
		PowerMorph.UnmorphFlash "DemonMorphFogOff";
	}
	
	
	override void InitEffect()
	{
		Super.InitEffect();
		if (Owner)
		{
			let inv = PowerInvulnerable(Owner.FindInventory("PowerInvulnerable",true));
			if (inv) inv.EffectTics = 0;
			Owner.bINVULNERABLE = true;
			if (!screams)
			{
				bool dumb = false;
				[dumb, screams] = A_SpawnItemEx("DemonMorphScreams",flags: SXF_NOCHECKPOSITION|SXF_SETTARGET);
				
			}
		}
	}
	
	/*
	override void DoEffect()
	{
		if (EffectTics <= 1)
			AEoDHandler.SendNetworkEvent("DemonMorphOff");
			
		Super.DoEffect();
	}
	*/
	
	override void EndEffect()
	{
		// Because this is apparently called when updating a powerup as well.
		if (EffectTics <= 1)
		{
			AEoDHandler.SendNetworkEvent("DemonMorphOff");
			if (screams)
			{
				for (int i = 1; i < 8; i++)
					screams.A_StopSound(i);
				screams.Destroy();
			}
			Shader.SetUniform1i(owner.player, "AEoD_RadialBlurShader", "blurSize", 1);
			Shader.SetEnabled(owner.player, "AEoD_RadialBlurShader", false);
		}
		Super.EndEffect();
	}
	
}

Class DemonPlayerMorph : DoomPlayer
{
	int blurSize;
	Default
	{
		//POWER OVERWHELMING.
		RipLevelMin 666;
		DamageFactor 0.0;
		DamageFactor "DemonMorph", 0;
		DamageFactor "HolyNoResist", 0;
		+NORADIUSDMG
		+NODAMAGE
		+NOPAIN
		+DONTMORPH
		+PICKUP
		+NOTIMEFREEZE
		+INVULNERABLE
		+PLAYERPAWN.NOTHRUSTWHENINVUL
		+PLAYERPAWN.CROUCHABLEMORPH
		+DONTTHRUST
		+TELESTOMP
		+LAXTELEFRAGDMG
		+NOSKIN
		+NOBLOOD
		+AIMREFLECT
		Health 666;
		Player.MorphWeapon "AEoDDemonMorphHand";
	}
	
	void EndMorph(bool kill = false)
	{
		if (kill)
			Die(null, null);
		else
		{
			let it1 = Powerup(FindInventory("PowerMorph",true));
			let it2 = Powerup(alternative.FindInventory("PowerMorph",true));
			let it3 = Powerup(FindInventory("PowerLightAmp",true));
			let it4 = Powerup(alternative.FindInventory("PowerLightAmp",true));
			if (it1)	it1.EffectTics = 0;
			if (it2)	it2.EffectTics = 0;
			if (it3)	it3.EffectTics = 0;
			if (it4)	it4.EffectTics = 0;
		}
	}
	
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		return 0;
	}
}


Class DemonMorphToken : Inventory
{
	Default
	{
		Inventory.InterhubAmount 0;
	}
}

Class AEoDDemonMorphHand : Weapon
{
	int sine;
	int first;
	int timer;
	PlayerInfo plr;
	transient Cvar CIntensity;
	double Intensity;
	const ShootFlags = ZOOM_INSTANT|ZOOM_NOSCALETURNING;
	Default
	{
		Inventory.InterhubAmount 0;
		+WEAPON.CHEATNOTWEAPON
		+INVENTORY.ALWAYSPICKUP
		+INVENTORY.QUIET
		+INVENTORY.NOSCREENFLASH
		+WEAPON.AMMO_OPTIONAL
		+INVENTORY.UNDROPPABLE
		+INVENTORY.UNTOSSABLE
		+THRUACTORS
	}
	
	action void SetShaders(bool on)
	{
		Shader.SetEnabled(invoker.owner.player, "AEoD_RadialBlurShader", on);
		//Shader.SetEnabled(invoker.plr, "AEoD_ZoomShader", on);
	}
	
	action void SetBlur(int amt)
	{
		Shader.SetUniform1i(invoker.owner.player, "AEoD_RadialBlurShader", "blurSize", amt);
	}
	
	action void ZoomBlur(double zoom, int blur, int flags = 0)
	{
		Shader.SetUniform1i(invoker.owner.player, "AEoD_RadialBlurShader", "blurSize", blur);
		A_ZoomFactor(zoom, flags);
	}
	
	action double GetIntensity()
	{
		if (invoker.CIntensity)
			return invoker.CIntensity.GetFloat();
		
		invoker.CIntensity = Cvar.GetCvar("AEoD_ShaderIntensity", invoker.owner.player);
		if (invoker.CIntensity)
			return invoker.CIntensity.GetFloat();
		
		return 0;
	}
	
	States
	{
	Spawn:
		M666 A 0;
		Stop;
	Overlay.Begin:
		M666 A 1 
		{
			A_PlaySound("DemonMorph/Loop",7|CHAN_NOPAUSE,1,1,ATTN_NONE);
			A_SetBlend("White",0.125,10);
		}
		M666 A 1 A_SetBlend("White",0.25,10);
		M666 A 1 A_SetBlend("White",0.375,10);
		M666 A 1 A_SetBlend("White",0.5,10);
		M666 A 1 A_SetBlend("White",0.625,10);
		M666 A 1 A_SetBlend("White",0.75,10);
		M666 A 1 A_SetBlend("White",0.875,10);
		M666 A 0
		{
			invoker.CIntensity = Cvar.GetCvar("AEoD_ShaderIntensity", invoker.owner.player);
			AEoDHandler.SendNetworkEvent("DemonMorphOn");
			A_SetBlend("White",1.0,10);
			A_SetInventory("DemonMorphFlashed",1);
			A_GiveInventory("DemonMorphFullBright",1);
			A_GiveInventory("NoAEoDHUDToken",1);
			ACS_NamedExecuteAlways("DemonMorphMusic",0,1,0,0);
			if (GetCvar("user_AllowDemonMorphMusic"))
			{
				A_SpawnItemEx("DemonMorphMusic",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_SETMASTER);
			}
		}
		Stop;
	Overlay.Invul:
		M666 A 4
		{
			bDONTMORPH = bDONTTHRUST = bNODAMAGE = bNOPAIN = bINVULNERABLE = true;
			RipLevelMin = 666;
			A_SetHealth(666);
		}
		Wait;
	Select:
		M666 A 0 
		{
			invoker.plr = invoker.owner.player;
			if (invoker.plr)
			{
				SetShaders(true);
				SetBlur(1);
			}
			A_Raise(20000);
		}
		Goto Ready;
	Deselect:
		M666 A 0 
		{
			A_SetInventory("DemonMorphFlashed",0);
			A_ClearOverlays();
			SetBlur(1);
			SetShaders(false);
			A_ZoomFactor(1.0);
			A_GiveInventory("DemonMorphRemoval",1);
			A_TakeInventory("DemonMorphActiveToken",1000,0);
			//A_GiveInventory("PentagramDispelled",1);
		}
		Goto DesLoop;
	DesLoop:
		M666 A 1 A_Lower(20000);
		Loop;
	Ready:
		M666 A 1
		{	
			if (!invoker.first)
			{
				A_SetInventory("DemonMorphFlashed",0);
				if (CountInv("PowerInvulBase"))
				{	A_GiveInventory("PentagramDispelled");	}
				A_Overlay(40001, "Overlay.Invul");
				A_Overlay(40002, "Overlay.Begin");
				A_WeaponOffset(0,32);
				invoker.first = 1;
			}
			A_WeaponReady(WRF_NOSWITCH|WRF_NOBOB);
			
			invoker.sine = (invoker.sine + 5) % 360;
			A_ZoomFactor(1 + (sin(invoker.sine) * 0.095),ZOOM_NOSCALETURNING);
		}
		Loop;
	Overlay.SineFire:
		M666 A 1 ;
		M666 A 0
		{
			invoker.sine = Max(1, invoker.sine - (100 * invoker.Intensity));
			
			if (invoker.sine <= 1)
			{
				// Destroy() on a weapon will completely fuck it up.
				return ResolveState("Null");
			}	
			
			return ResolveState(null);
		}
		Loop;
	AltFire:
	Fire:
		//Note: The damage has been moved directly to the puff itself so it can ignore damagefactors.
		M666 A 0 
		{
			A_RailAttack(20000,0,0,-1,-1,RGF_SILENT,0,"DeathTouchPuff",0,0,32766,0,16,0,"DemonMorphExploder");
			A_SpawnItemEx("DemonMorphShootingSound", flags: SXF_NOCHECKPOSITION);
			invoker.Intensity = GetIntensity();
			if (invoker.Intensity > 0)
			{
				SetShaders(true);
				invoker.sine = 1 + (invoker.Intensity * 1000);
				A_Overlay(40003, "Overlay.SineFire");
			}
			else
				SetShaders(false);
		}
		M666 A 1 ZoomBlur(2.000,invoker.sine,ShootFlags);
		M666 A 1 ZoomBlur(1.500,invoker.sine,ShootFlags);
		M666 A 1 ZoomBlur(1.250,invoker.sine,ShootFlags);
		M666 A 1 ZoomBlur(1.000,invoker.sine,ShootFlags);
		M666 A 1 ZoomBlur(0.980,invoker.sine,ShootFlags);
		M666 A 1 ZoomBlur(0.960,invoker.sine,ShootFlags);
		M666 A 1 ZoomBlur(0.940,invoker.sine,ShootFlags);
		M666 A 1 ZoomBlur(0.930,invoker.sine,ShootFlags);
		M666 A 1 ZoomBlur(0.940,invoker.sine,ShootFlags);
		M666 A 1 ZoomBlur(0.960,invoker.sine,ShootFlags);
		M666 A 1 ZoomBlur(0.980,invoker.sine,ShootFlags);
		M666 A 1 ZoomBlur(1.000,invoker.sine,ShootFlags);
		M666 A 1 ZoomBlur(1.020,invoker.sine,ShootFlags);
		M666 A 1 ZoomBlur(1.030,invoker.sine,ShootFlags);
		M666 A 1 ZoomBlur(1.040,invoker.sine,ShootFlags);
		M666 A 1 ZoomBlur(1.030,invoker.sine,ShootFlags);
		M666 A 1 ZoomBlur(1.020,invoker.sine,ShootFlags);
		M666 A 1 ZoomBlur(1.015,invoker.sine,ShootFlags);
		M666 A 1 ZoomBlur(1.010,invoker.sine,ShootFlags);
		M666 A 1 ZoomBlur(1.005,invoker.sine,ShootFlags);
		M666 A 0 
		{
			A_Overlay(40003, "Null");
			invoker.sine = 0;
			SetBlur(1);
			A_Refire();
		}
		Goto Ready;
	Remove:
		M666 A 1 A_TakeInventory("AEoDDemonMorphHand",1000,0);
		Goto Deselect;
	}
}

Class DemonMorphMusic : Actor
{
	Default
	{
		+NOINTERACTION
		+NOTONAUTOMAP
		RenderStyle "None";
	}
	States
	{
	Spawn:
		TNT1 A 0 NoDelay
		{
			A_PlaySound("Synthetic666",5,1,1,ATTN_NONE);
		}
	Waiting:
		TNT1 A 5
		{
			if (CountInv("PowerDemonMorph",MasterPtr))
			{	return ResolveState(null);	}
			A_StopSound(5);
			return ResolveState("Null");
		}
		Loop;
	}
}

Class DemonMorphShootingSound : Actor
{
	Default
	{
		+NOINTERACTION
		+NOTIMEFREEZE
		+NOTONAUTOMAP
	}
	States
	{
	Spawn:
		TNT1 A 1 NoDelay
		{
			if (random(0,1))
			{
				A_PlaySound("DemonMorph/Shoot1",5|CHAN_NOPAUSE,1,0,ATTN_NONE);
				A_PlaySound("DemonMorph/Shoot1",7|CHAN_NOPAUSE,1,0,ATTN_NONE);
			}
			else
			{
				A_PlaySound("DemonMorph/Shoot2",5|CHAN_NOPAUSE,1,0,ATTN_NONE);
				A_PlaySound("DemonMorph/Shoot2",7|CHAN_NOPAUSE,1,0,ATTN_NONE);
			}
		}
		Stop;
	}
}
		

Class DemonMorphExploder : Actor
{
	Default
	{
		Projectile;
		+NOINTERACTION
		+NODAMAGETHRUST
		+FORCERADIUSDMG
		+EXTREMEDEATH
		+NOTIMEFREEZE
		+PUFFGETSOWNER
		+NOTONAUTOMAP
		+DONTSPLASH
		DamageType "DemonMorph";
		Renderstyle "None";
	}
	States
	{
	Spawn:
		TNT1 A 0 NoDelay A_Explode(666,66,0,0,66);
		Stop;
	}
}

Class DeathTouchPuff : Actor
{
	Default
	{
		Projectile;
		+ALWAYSPUFF
		+NOINTERACTION
		+DONTSPLASH
		+PUFFGETSOWNER
		+FORCERADIUSDMG
		+PUFFONACTORS
		+NOTIMEFREEZE
		+NOTONAUTOMAP
		//+HITTRACER
		+EXTREMEDEATH
		+DONTSPLASH
		DamageType "DemonMorph";
		Renderstyle "None";
	}
	States
	{
	Spawn:
		TNT1 A 0 NoDelay A_Explode(666,66,0,0,66);
		Stop;
	}
}

Class DemonMorphFogOff : Actor
{
	Default
	{
		+NOINTERACTION
		+NOTIMEFREEZE
	}
	States
	{
	Spawn:
		TNT1 A 1 NoDelay 
		{
			A_GiveInventory("DemonMorphRemoval",1,TargetPtr);
			
			ThinkerIterator it = ThinkerIterator.Create("DemonMorphScreams");
			Actor mo;
			while (mo = DemonMorphScreams(it.Next()))
			{
				// Make sure the targets align.
				if (mo is "DemonMorphScreams")
				{
					for (int i = 1; i < 8; i++)
					{	
						A_StopSound(i);
					}
					mo.Destroy();
				}
			}
		}
		Stop;
	}
}

Class DemonMorphRemoval : CustomInventory
{
	Default
	{
		+INVENTORY.ALWAYSPICKUP
	}
	States
	{
	Pickup:
		TNT1 A 0 
		{
			ACS_NamedExecuteAlways("DemonMorphMusic",0,0,0,0);
			A_SetInventory("PentagramIsOn",0,0);
			A_SetInventory("PentagramCountdown",0);
			A_SetInventory("PentagramDispelled",0);
			A_SetInventory("PowerInvulBase",0);
			A_SetInventory("DemonMorphActiveToken",0);
			A_SetInventory("PowerDemonMorph",0);
			A_SetInventory("NoAEoDHUDToken",0);
			A_SetInventory("DemonMorphFlashed",0);
			bNODAMAGE = bNOPAIN = false;
			bJUSTHIT = true;
			A_SetInventory("MorphToken",0);
			A_StopSound(5);
			A_StopSound(6);
			A_StopSound(7);
			A_SetBlend("White",1.0,10);
			A_PlaySound("DemonMorph/Stop",5,1,0,ATTN_NONE);
			A_Explode(30000,2048,XF_NOTMISSILE,0,2048,0,0,null,"Telefrag");
			A_GiveInventory("DemonMorphScreen",1);
			A_SetHealth(Clamp(CountInv("TempHealthToken"), 200 + stamina, 666));
			A_SetInventory("TempHealthToken",0);
		}
		Stop;
	}
}

Class GeneralMorphFogOff : Actor
{
	Default
	{
		+NOINTERACTION
		+NOTIMEFREEZE
	}
	States
	{
	Spawn:
		TNT1 A 1 NoDelay A_GiveInventory("GeneralMorphRemoval",1,AAPTR_TARGET);
		Stop;
	}
}

Class GeneralMorphRemoval : CustomInventory
{
	Default
	{
		+INVENTORY.ALWAYSPICKUP
	}
	States
	{
	Pickup:
		TNT1 A 0 
		{
			A_TakeInventory("SSLSecondShotToken",32767);
			A_TakeInventory("SSRSecondShotToken",32767);
			A_TakeInventory("PentagramIsOn",9999,0);
			A_TakeInventory("PentagramCountdown",9999,0);
			A_TakeInventory("PentagramDispelled",9999,0);
			A_TakeInventory("PowerInvulBase",10000,0);
			A_TakeInventory("DemonMorphActiveToken",1000,0);
			A_TakeInventory("PowerDemonMorph",1000,0);
			A_TakeInventory("NoAEoDHUDToken",1000,0);
			bNODAMAGE = bNOPAIN = false;
			bJUSTHIT = true;
			A_StopSound(5);
			A_StopSound(6);
			A_StopSound(7);
			A_SetBlend("White",1.0,10);
			A_PlaySound("DemonMorph/Stop;",5,1,0,ATTN_NONE);
			A_GiveInventory("DemonMorphScreen",1);
			A_SetHealth(Clamp(CountInv("TempHealthToken"),200 + stamina,666));
			A_TakeInventory("TempHealthToken",32767,0);
		}
		Stop;
	}
}

Class DemonMorphActiveToken : Inventory
{
	Default
	{
		Inventory.MaxAmount 1;
		Inventory.InterHubAmount 0;
	}
}

Class DemonMorphScreen : PowerupGiver
{
	Default
	{
		+INVENTORY.AUTOACTIVATE
		+INVENTORY.QUIET
		Powerup.Type "PowerInvulBase";
		Powerup.Duration 35; //9000000
	}
}

Class DemonMorphFullBright : PowerupGiver
{
	Default
	{
		+INVENTORY.AUTOACTIVATE
		+INVENTORY.QUIET
		+INVENTORY.ADDITIVETIME
		Powerup.Type "PowerDemonAmp";
		Powerup.Duration 1225;
		Inventory.MaxAmount 0;
	}
}


Class PowerDemonAmp : PowerLightAmp
{
	// Invert the function so that it's actually grayscale (see EventHandler).
	override bool IsBlinking()
	{
		if (!Owner.CountInv("DemonMorphFlashed"))
		{	return true;	}
		return !Super.IsBlinking();
	}
}

Class PowerDMScreen : PowerProtection
{
	Default
	{
		DamageFactor 0.0;
	}
}

Class DemonMorphScreams : Actor
{
	int ticking;
	int count;
		
	Default
	{
		Projectile;
		+NOINTERACTION
		+NOTIMEFREEZE
		+NOTONAUTOMAP
		+NODAMAGE
		+DONTSPLASH
		RenderStyle "None";
	}
	States
	{
	Spawn:
		//This part is needed so the morph has the chance to actually kick in 
		//before it checks, otherwise it won't work. It's never accessed again.
		TNT1 A 35 NoDelay
		{
			if (target && target.CountInv("AEoDDemonMorphHand"))
			{
				A_PlaySound("DemonMorph/Scream",CHAN_AUTO|CHAN_NOPAUSE,1,0,ATTN_NONE);
				A_SetTics(35 * random(1,3));
				return ResolveState(null);
			}
			return ResolveState("End");
		}
		Wait;
	End:
		TNT1 A 0 
		{
			A_StopSound(CHAN_AUTO);
			A_StopSound(CHAN_WEAPON);
			A_StopSound(CHAN_ITEM);
			A_StopSound(CHAN_VOICE);
			A_StopSound(CHAN_BODY);
			A_StopSound(5);
			A_StopSound(6);
			A_StopSound(7);
		}
		Stop;
	}
}

//------------------------------------------------------------------------------
// This is responsible for turning enemies yellow-orange and allies blue.
Class DemonMorphTranslationItem : Inventory
{
	uint OldTranslation;
	uint CurrentTranslation;
	uint FriendlyTranslation;
	uint EnemyTranslation;
	bool wasFriendly;
	bool resurrecting;
	bool DestroyMe;
	bool restored;
	
	override bool TryPickup(in out Actor toucher)
	{
		if (!toucher || toucher.health < 1 || toucher.CountInv(GetClass()))
			return false;
		
		bool good = Super.TryPickup(toucher);
		if (good && toucher)
		{
			restored = false;
			OldTranslation = toucher.Translation;
			toucher.A_SetTranslation("DemonMorphAlly");
			FriendlyTranslation = toucher.Translation;
			toucher.A_SetTranslation("DemonMorphTarget");
			EnemyTranslation = toucher.Translation;
			
			if (toucher.bFRIENDLY)	{ toucher.A_SetTranslation("DemonMorphAlly"); wasFriendly = true; }
			else						toucher.A_SetTranslation("DemonMorphTarget");
			
			toucher.bBRIGHT = true;
			CurrentTranslation = toucher.Translation;
			//Console.Printf("Translation set");
		}
		return good;
	}
	
	//==========================================================================
	//
	// The tick function.
	//
	//==========================================================================
	override void DoEffect()
	{
		// Destroy the thinker if we no actor, or actor's dead.
		if (DestroyMe || !owner || owner.health < 1)
		{
			DepleteOrDestroy();
			return;
		}
		Super.DoEffect();
		// No point doing anything if invisible.
		if (owner.alpha <= 0 || owner.GetRenderStyle() <= 0 || 
			owner.bINVISIBLE || owner.bNOSECTOR)
			return;
		
		
		// Change the translation based on friendly or not.
		// Make sure not to record it by changing the base and current
		// at the same time.
		if (!wasFriendly && owner.bFRIENDLY)
		{
			owner.Translation = CurrentTranslation = FriendlyTranslation;
		}
		else if (wasFriendly && !owner.bFRIENDLY)
		{
			owner.Translation = CurrentTranslation = EnemyTranslation;
		}
		wasFriendly = owner.bFRIENDLY;
		
		// Should their translation change at any point, record it.
		if (owner.Translation != CurrentTranslation)
			OldTranslation = owner.Translation;
		
		// Then set it again, and done.
		owner.Translation = CurrentTranslation;
		owner.bBRIGHT = true;
		restored = false;
	}
	//==========================================================================
	//
	// As of switching to inventory items, this actually works for
	// monsters that burst into fragments thanks to the special handling of
	// inventory items upon death.
	//
	// Why do we need all three of these functions? Simply put, calling a
	// function is very time critical. This ensures all corner cases are
	// covered and all escape paths are cut off, ensuring the gibs are
	// returned to normal.
	// 
	// For example, OwnerDied in the super function calls Destroy() which then
	// has to process some other stuff first. By this time it may be too late.
	// Because this is all processed in a virtual machine, this is one exception
	// to making a function call for doing the work. It may be tidier, but
	// call speed is imperative if we want things happening in the proper order.
	// 
	//==========================================================================
	override void OwnerDied()
	{
		if (owner && !restored)
		{
			owner.Translation = OldTranslation;
			owner.bBRIGHT = false;
			restored = true;
		}
		Super.OwnerDied();
	}
	override void OnDestroy()
	{
		if (owner && !restored)
		{
			owner.Translation = OldTranslation;
			owner.bBRIGHT = false;
			restored = true;
		}
		Super.OnDestroy();
	}
	override void DepleteOrDestroy()
	{
		if (owner && !restored)
		{
			owner.Translation = OldTranslation;
			owner.bBRIGHT = false;
			restored = true;
		}
		Super.DepleteOrDestroy();
	}
}