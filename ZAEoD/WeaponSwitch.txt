/*==============================================================================
================================================================================
	AEons of Death 6.66 -- Weapon Switching Core
 
	By Major Cooke
 ------------------------------------------------------------------------------
	This is the meat and bones of the weapon switching. Every weapon has a cvar
	named exactly to it, appended by 'user_'. 
 
	I.e. AEoDTNT's cvar is user_AEoDTNT

	This allows easy integration with almost no changes to any DECORATE or
	ZScript weapon required. So far, the only change needed was to give them 
	inheritance from AEoDWeaponBase. More importantly, they must inherit from
	AEoDWeaponSlot## (in range [01, 10]). Then, assigning them via regular means
	such as KEYCONF, players, or SlotPriority (ranging [0.0, 1.0]) is the last
	task.
	
	The cvar of the weapon must not conflict with any other in that same group,
	or it runs the risk of being overridden.
	
================================================================================
==============================================================================*/


// Because GZDoom crashes with trying to do array[0].arrayAccessor[1].etc...
// I've found the need to copy most of the internal functions over.
Class AEoDWeaponContainer play
{
	Array<AEoDWeaponBase> Weapons;
	int TSlot;
	
	// Some simple stuff. 
	override void OnDestroy() 	{	Weapons.Clear(); Super.OnDestroy(); }
	void 	Init(int s)			{	Weapons.Clear(); TSlot = s;	}
	void 	Clear()				{	Weapons.Clear();	}
	uint 	GetSize() 			{	return Weapons.Size(); }
	
	// Gets the weapon at the specified position.
	AEoDWeaponBase Get(uint pos)
	{
		return (pos >= 0 && pos < Weapons.Size()) ? Weapons[pos] : null;
	}
	
	// Attempts to find the position of the weapon if available.
	uint Find(AEoDWeaponBase who)		
	{
		return (who) ? Weapons.Find(who) : Weapons.Size();
	}
	
	// Makes a weapon ineligible for counting towards 
	void Delete(uint index, int deletecount = 1)
	{
		Weapons.Delete(index, deletecount);
	}
	
	// Inserts a weapon at an index.
	void Insert(uint index, AEoDWeaponBase item)
	{
		// Name nam = (item) ? (item.GetClassName()) : 'Null';
		// Console.Printf("Added %s to slot %d, index %d", nam, TSlot, index);
		Weapons.Insert(index, item);	
	}
	
	uint Push(AEoDWeaponBase item)
	{
		return Weapons.Push(item);
	}
	
	// Gets the highest and lowest ranking weapon indexes of available weapons
	// in the player inventory. Used by the system to determine where
	// to begin the search at for the next weapon.
	int, int GetCaps()
	{
		int Hi = -1, Lo = 1000;
		
		if (Weapons.Size() < 1)	
		{
			//Console.Printf("Weapons size < 1");
			return -1, -1;
		}
		int count = 0;
		//Console.Printf("4.001");
		for (int i = 0; i < Weapons.Size(); i++)
		{
			if (Weapons[i] == null)	
			{
				//Console.Printf("%d was null", i);
				continue;
			}
			//Console.Printf("4.0010");
			let wep = AEoDWeaponBase(Weapons[i]);
			//Console.Printf("4.0011");
			
			if (wep)
			{
				int dex = AEoDWeaponIdentifier.GetModIndex(wep);
				if (dex < 1)
				{
					//Console.Printf("Dex: %d", dex);
					continue;
				}
				count++;
				Hi = Max(Hi, dex);
				Lo = Min(Lo, dex);
				
			}
		}
		//Console.Printf("4.002");
		if (!count)
			return -1, -1;
		return Hi, Lo;
	}
	
	// Tries to find a weapon with the specified slot index in particular.
	AEoDWeaponBase GetSpecific(uint Index)
	{		
		if (Weapons.Size() < 1)
			return null;
		
		if (Index < 1)
		{
			//Console.Printf("Index is < 1");
			return null;
		}
		
		//Console.Printf("3.001");
		for (int i = 0; i < Weapons.Size(); i++)
		{
			let wep = AEoDWeaponBase(Weapons[i]);
			if (!wep || !(wep is "AEoDWeaponBase"))
				continue;
			if (AEoDWeaponIdentifier.GetModIndex(wep) == Index)
				return wep;
		}
		//Console.Printf("3.002");
		return null;
	}
}

//==============================================================================
// AEoDWeaponIndexer
// 
// This royal pain in my ass essentially acts as a 3D array
// manager due to GZDoom being completely unable to handle dynamic arrays
// inside of dynamic arrays. It just crashes on parsing. So it does all the
// dirty work when needed because I grew tired of trying to sort shit myself.
//==============================================================================

Class AEoDWeaponIndexer : Object play
{
	const Size = 10;
	AEoDWeaponContainer Base[Size];
	AEoDWeaponBase CurrentWeapon;
	
	override void OnDestroy()
	{
		for (int i = 0; i < Size; i++)
			if (Base[i])
				Base[i].Destroy();
	}
	
	void Init(AEoDWeaponBase current)
	{
		CurrentWeapon = current;
		//Console.Printf("2");
		for (int i = 0; i < Size; i++)
		{
			Base[i] = new("AEoDWeaponContainer");
			Base[i].Init(i);
		}
		//Console.Printf("3");
	}
	
	bool CheckRange(uint Slot) const	{	return (Slot > -1 && Slot < Size);	}
	
	void ClearAt(int Slot = -1)
	{
		if (!CheckRange(Slot))
		{
			for (int i = 0; i < Size; i++)
				if (Base[i])
					Base[i].Clear();
		}
		else if (Base[Slot])	Base[Slot].Clear();
	}
	void InsertAt(uint Slot, uint index, AEoDWeaponBase item)
	{
		if (!item || !CheckRange(Slot))	
		{
			//Console.Printf("Tried to insert non-weapon at Slot %d Index %d", Slot, index);
			return;
		}
		
		if (Base[Slot])
			Base[Slot].Insert(index, item);
		//else Console.Printf("Base[%d] is null!", Slot);
	}
	
	void PushAt(uint Slot, AEoDWeaponBase item)
	{
		if (!CheckRange(Slot))	return;
		
		if (Base[Slot])
			Base[Slot].Push(item);
		//else Console.Printf("-2");
	}
	void DeleteAt(uint Slot, uint index, int deletecount = 1)
	{
		if (!CheckRange(Slot))	return;
		
		if (Base[Slot])
			Base[Slot].Delete(index, deletecount);
	}
	
	// The meat of the array searching is here. 
	AEoDWeaponBase FindNextWeapon(bool prev, uint Slot, uint Index, bool SameSlot = false)
	{
		AEoDWeaponBase Pointer = null;
		bool FixHiLo = false;
		int CurSlot = Slot, CurIndex = Index, SlotsChecked = 0;
		int Direction = (prev) ? -1 : 1;
		int hi = -1, lo = -1;
		//Console.Printf("2.001");
		if (SameSlot)
		{
			if (!Base[Slot] || Base[Slot].GetSize() < 1)
				return null;
			//Console.Printf("2.002");
			
			[hi, lo] = Base[Slot].GetCaps();
			if (hi == -1 || lo == -1)
				return null;
			//Console.Printf("2.003");
			do
			{
				//Console.Printf("2.004 + %d", CurIndex);
				Pointer = Base[Slot].GetSpecific(CurIndex);
				if (Pointer && Pointer != CurrentWeapon && CheckWeaponSwitch(Pointer))
				{
					return Pointer;
				}
				CurIndex += Direction;
				if (prev)	
				{
					if (CurIndex < lo) CurIndex = hi;
				}
				else
				{
					if (CurIndex > hi) CurIndex = lo;
				}
					
			}	while (CurIndex != Index);
		}
		else
		{
			do
			{
				hi = lo = -1;
				if (!Base[CurSlot])
				{
					//Console.Printf("-2.001 + %d", SlotsChecked);
					SlotsChecked++;
					CurSlot += Direction;
					if (prev)	
					{
						if (CurSlot < 0) CurSlot = 9;
					}
					else
					{
						if (CurSlot > 9) CurSlot = 0;
					}
					continue;
				}
				//Console.Printf("2.006");
				[hi, lo] = Base[CurSlot].GetCaps();
				
				//Console.Printf("2.007");
				
				if (FixHiLo)
				{
					CurIndex = (prev) ? lo : hi;
					FixHiLo = false;
					//Console.Printf("%d -- %d, %d", CurIndex, hi, lo);
				}
				if (hi == -1 || lo == -1 || CurIndex > hi || CurIndex < lo)
				{
					FixHiLo = true;
					SlotsChecked++;
					CurSlot += Direction;
					if (prev)
					{
						if (CurSlot < 0)
							CurSlot = Size - 1;
					}
					else
					{
						CurSlot %= Size;
					}
					continue;
				}
				/*
				if (prev)
				{
					
					if (hi == -1 || lo == -1 || CurIndex < lo)
					{
						FixHiLo = true;
						SlotsChecked++;
						CurSlot--;
						if (CurSlot < 0)	CurSlot = Size - 1;	
						continue; // hi and lo must be refreshed again.
					}
					if (FixHiLo && CurIndex < lo)
						CurIndex = hi;
					
				}
				else
				{
					if (hi == -1 || lo == -1 || CurIndex > hi)
					{
						FixHiLo = true;
						CurIndex = lo;
						SlotsChecked++;
						CurSlot = (CurSlot + 1) % Size;
						continue;
					}
					if (FixHiLo && CurIndex > hi)
						CurIndex = lo;
					
				}
				*/
				FixHiLo = false;
				//Console.Printf("2.007 | Slot: %d | Index %d", CurSlot, CurIndex);
				Pointer = Base[CurSlot].GetSpecific(CurIndex);
				
				if (Pointer && Pointer != CurrentWeapon && CheckWeaponSwitch(Pointer))
				{
					// Insert a bunch of weapon checks here.
					return Pointer;
				}
				CurIndex -= Direction;
				
				if (SlotsChecked > Size)
					return null;
			}	while ((CurIndex != Index || CurSlot != Slot) && SlotsChecked <= Size)
		}
		return null;
	}
	
	//==========================================================================
	// FindFirstSlotWeapon
	//
	// Used for getting the highest ranking weapon available.
	//==========================================================================
	AEoDWeaponBase FindFirstSlotWeapon(uint Slot)
	{
		AEoDWeaponBase Pointer = null;
		int hi = -1, lo = -1;
		if (Base[Slot])
		{
			//Console.Printf("1.001");
			[hi, lo] = Base[Slot].GetCaps();
		}
		if (hi == -1 || lo == -1)
		{
			//Console.Printf("-1.001 | %d %d", lo, hi);
			return null;
		}
		//Console.Printf("%d %d", lo, hi);
		Pointer = Base[Slot].GetSpecific(lo);
		return Pointer;
	}
	
	// Simply does the ammo check if the weapon has enough ammmo to switch to it.
	bool CheckWeaponSwitch(AEoDWeaponBase item)
	{
		if (item)
		{
			Cvar Check = Cvar.FindCvar("sv_dontcheckammo");
			if (item.CheckAmmo(Weapon.EitherFire, false) || (Check && Check.GetBool()))
				return true;	
		}
		return false;
	}
}

//==============================================================================
//==============================================================================
// The main weapon switching class.
// Creates the above class which acts as an array manager. 
//==============================================================================
//==============================================================================
Class AEoDWeaponIdentifier : Object play
{
	enum EInstruction
	{
		Ins_SetSlot,
		Ins_SetNext,
		Ins_SetPrev
	};
	int Instruction;
	PlayerInfo plr;
	AEoDWeaponIndexer Base;
	
	override void OnDestroy()
	{
		if (Base)	Base.Destroy();
		Super.OnDestroy();
	}
	
	// First off, fill the appropriate arrays with the current weapon slot data.
	// Find the name of its cvar and check if it's at the beginning or end.
	// If repeat is false, get the next desired weapon's slot.
	Weapon GetNextWeapon(PlayerInfo player, int command, int DesiredSlot = -1)
	{
		int CurrentSlot = 0, CurrentIndex = 0, NextSlot = 0, NextIndex = 0;
		if (!player || command < 0 || command > 2)	
		{
			//Console.Printf("-1");
			return null;
		}
		plr = player;
		DesiredSlot %= 10;
		Instruction = command;
		
		// Get the current weapon and find its slot.
		// Then gather the list of cvars and find its position.
		let wep = AEoDWeaponBase(player.ReadyWeapon);
		if (wep)
		{
			Class<Weapon> check = wep.GetClass();
			if (check)
			{	
				bool found;
				[found, CurrentSlot] = player.weapons.LocateWeapon(check);
				CurrentIndex = AEoDWeaponIdentifier.GetModIndex(wep);	// Ignore the real index. Get the mod index instead.
			}
		}
		else if (command == Ins_SetNext || command == Ins_SetPrev)
		{
			// Special case: In the event the player doesn't have a weapon up,
			// hijack the command to be a direct slot instead.
			if (DesiredSlot < 0)
			{
				command = Ins_SetSlot;
			}
		}
		//Console.Printf("1");
		Base = new("AEoDWeaponIndexer"); Base.Init(wep);
		if (DesiredSlot < 0)	DesiredSlot = CurrentSlot;
		
		
		
		//...This has to be the weirdest method of traversing
		// inventory that I've ever encountered!
		// Anyway, go through and grab all AEoDWeaponBase classes already
		// in the player's inventory.
		int pushed = 0;
		for (let probe = player.mo.Inv; probe != null; probe = probe.Inv)
		{
			// Search through the inventory and collect all weapons belonging to
			// AEoD, except for the current one.
			let Weap = AEoDWeaponBase(probe);
			if (Weap && (Weap is "AEoDWeaponBase") && 
				//Weap != player.ReadyWeapon && 
				Weap.Amount > 0 && Weap.SlotNumber > -1)
			{
				pushed++;
				int Slot = Weap.SlotNumber;
				int Index = AEoDWeaponIdentifier.GetModIndex(Weap);
				if (Index > 0)
				{
					//Console.Printf("%d %d - %s", Slot, Index, Weap.GetClassName());
					//Base.InsertAt(Slot, Index, Weap);
					Base.PushAt(Slot, Weap);
				}
			}
		}
		//Console.Printf("4");
		if (pushed < 1)
			return null;
		//Console.Printf("5");
		AEoDWeaponBase NextWeapon = null;
		bool SameSlot = false;
		
		Switch(Instruction)
		{
			Case Ins_SetSlot:
			{
				if (DesiredSlot != CurrentSlot)
				{
					//Console.Printf("5.1 - Desired: %d - Current: %d", DesiredSlot, CurrentSlot);
					if (!Base)		
						return null;
					NextWeapon = Base.FindFirstSlotWeapon(DesiredSlot);
					//Console.Printf("6");
					return (NextWeapon) ? Weapon(NextWeapon) : null;
				}
				SameSlot = true;
			}
			Case Ins_SetNext:
			{
				//Console.Printf("5.2");
				if (!Base)
					return null;
				NextWeapon = Base.FindNextWeapon(false, CurrentSlot, CurrentIndex, SameSlot);
				//Console.Printf("6");
				return (NextWeapon) ? Weapon(NextWeapon) : null;
			}
			Case Ins_SetPrev:
			{
				//Console.Printf("5.3");
				if (!Base)
					return null;
				NextWeapon = Base.FindNextWeapon(true, CurrentSlot, CurrentIndex, SameSlot);
				//Console.Printf("6");
				return (NextWeapon) ? Weapon(NextWeapon) : null;
			}
		}
		return null;
	}
	
	static Int GetModIndex(AEoDWeaponBase item)
	{	
		//Console.Printf("6.001");
		if (!item || !item.owner || !(item is "AEoDWeaponBase"))	
		{
			//Console.Printf("Null or bad item");
			return -1;
		}
		//Console.Printf("6.002");
		
		Name cname = item.GetClassName();
		Name AEoDCvar = 'user_'..cname;
		//Console.Printf("6.003");
		Cvar check = Cvar.GetCvar(AEoDCvar, item.owner.player);
		//Console.Printf("6.004");
		if (!check || check.GetInt() < 1)
		{
			
			if (!check)						Console.Printf("ERROR: %s is NOT a cvar!", AEoDCvar);
			else if (check.GetInt() < 1)	Console.Printf("ERROR: %s is < 1!", AEoDCvar);
			return -1;
		}
		return check.GetInt();
	}
	
	int GetCvarInt(String Cvarname, PlayerInfo player)
	{
		int ret = -1;
		if (Cvarname.Length() < 1)	return ret;
		Cvar thing = null;
		
		if (player)		thing = Cvar.GetCvar(Cvarname, player);
		else			thing = Cvar.FindCvar(Cvarname);
		
		return (thing) ? thing.GetInt() : ret;
		
	}
}